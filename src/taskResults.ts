
import { LoadIssue } from "./loader"
import fs = require('fs');

const eventTimeWindow: number  = 5000 // 5 seconds

const createHtml = (issuesTable: string, eventsTable: string, shameTable: string) => `
  <html>
    <head>
      <style>
        table {
          width: 60%;
        }
        tr {
          text-align: left;
          border: 1px solid black;
        }
        th, td {
          padding: 15px;
        }
        tr:nth-child(odd) {
          background: #CCC
        }
        tr:nth-child(even) {
          background: #FFF
        }
        .no-content {
          background-color: red;
        }
      </style>
    </head>
    <body>
        <center>
            <font size="+3"><b>Loader report: </b></font><br>
            ${issuesTable}
            <font size="+3"><b>Hall of shame: </b></font><br>
            ${shameTable}
            <font size="+3"><b>Events report: </b></font><br>
            ${eventsTable}
        </center>
        <br>
        Generated by Squadron303 - https://github.com/matzak/squadron303
    </body>
  </html>
`;

const createIssueRow = (item: LoadIssue) => `
  <tr>
    <td>${item.callsign}</td>
    <td>${item.cantParse}</td>
    <td>${item.noBaroData}</td>
    <td>${item.fixInterval}</td>
  </tr>
`;

const createIssueTable = (rows: string) => `
  <table>
    <tr>
        <th>CN</td>
        <th>Can't parse</td>
        <th>No BARO data</td>
        <th>Fix interval</td>
    </tr>
    ${rows}
  </table>
`;

const createEventRow = (item: CloseCall) => `
  <tr>
    <td>${item.glider1}</td>
    <td>${item.glider2}</td>
    <td>${item.time}</td>
    <td>${Math.floor(item.distance)}</td>
    <td>${item.altitudeDifference}</td>
  </tr>
`;

const createEventsTable = (rows: string) => `
  <table>
    <tr>
        <th>CN #1</td>
        <th>CN #2</td>
        <th>Time</td>
        <th>Distance (meters)</td>
        <th>Altitude difference (meters)</td>
    </tr>
    ${rows}
  </table>
`;

const createShameRow = (item: [number, string, number]) => `
  <tr>
    <td>${item[0]}</td>
    <td>${item[1]}</td>
    <td>${item[2]}</td>
  </tr>
`;

const createShameTable = (rows: string) => `
  <table>
    <tr>
        <th>#</td>
        <th>CN</td>
        <th>Number of events</td>
    </tr>
    ${rows}
  </table>
`;

class CloseCall {
    glider1: string
    glider2: string
    time: string
    distance: number
    altitudeDifference: number
    timestamp: number

    constructor(glider1: string, glider2: string, time: string, distance: number, altDifference: number, timestamp: number) {
        this.glider1 = glider1
        this.glider2 = glider2
        this.time = time
        this.distance = distance
        this.altitudeDifference = altDifference
        this.timestamp = timestamp
    }
}

class TaskResults {
    private loadIssues?: LoadIssue[]
    private closeCalls: CloseCall[] = []
    private lastEvent?: CloseCall = undefined

    reportLoadIssues(loadIssues: LoadIssue[]) {
        this.loadIssues = loadIssues
    }

    //TODO: refactoring needed as it may generate invalid data if used in wrong order
    reportEvent(closeCall: CloseCall) {
        if (this.lastEvent != undefined) {
            if (closeCall.glider1 == this.lastEvent.glider1 && 
                closeCall.glider2 == this.lastEvent.glider2 && 
                Math.abs(closeCall.timestamp - this.lastEvent.timestamp) <= eventTimeWindow) {
                    // do nothing, event should be skipped
                }
            else {
                this.closeCalls.push(closeCall)
            }
        }
        else {
            this.closeCalls.push(closeCall)
        }
        this.lastEvent = closeCall
    }

    loadIssuesToConsole() {
        console.log("Loader report:")
        console.log(this.loadIssues)
    }

    eventsToConsole() {
        this.closeCalls.forEach(closeCall => {
            console.log(closeCall.glider1, " vs ", closeCall.glider2, " at ", closeCall.time, "(distance: ", closeCall.distance,", alt difference:", closeCall.altitudeDifference)

        });
        console.log("Total number of events:", this.closeCalls.length)
    }

    private shameResults: Map<string, number> = new Map<string, number>()


    hallOfShameToConsole() {
        this.generateShameData()
        var position = 1

        console.log("Hall of shame")
        for (let [key, value] of this.shameResults) {
            console.log("#", position, " ", key + ' ' + value);
            position++
        }
    }

    generateHTMLReport() {
        const issueRows = this.loadIssues?.map(createIssueRow).join('') ?? ""
        const issueTable = createIssueTable(issueRows)
        const eventRows = this.closeCalls.map(createEventRow).join('')
        const eventTable = createEventsTable(eventRows)
        
        this.generateShameData()

        var position = 1
        let shameInput: [number, string, number][] = []
        for (let [key, value] of this.shameResults) {
            shameInput.push([position, key, value])
            position++
        }
        
        const shameRows = shameInput.map(createShameRow).join('')
        const shameTable = createShameTable(shameRows)

        const htmlReport = createHtml(issueTable, eventTable, shameTable)

        fs.writeFileSync("report.html",htmlReport)
    }

    private generateShameData() {
        this.shameResults = new Map<string, number>()

        this.shameResults[Symbol.iterator] = function* () {
            yield* [...this.entries()].sort((a, b) => b[1] - a[1]);
        }
        
        
        this.closeCalls.forEach(closeCall => {            
            let glider1Score = this.shameResults.get(closeCall.glider1) ?? 0
            let glider2Score = this.shameResults.get(closeCall.glider2) ?? 0
 
            this.shameResults.set(closeCall.glider1, glider1Score+1)
            this.shameResults.set(closeCall.glider2, glider2Score+1)
        })
    }
}

export { TaskResults, CloseCall }